from fiber import sleep
from random.pseudo import randint
from sdl import sdl_init
from sdl import ttf_init
from sdl import create_window_and_renderer
from sdl import create_rgb_surface
from sdl import img_init
from sdl import img_load
from sdl import poll_event
from sdl import get_performance_counter
from sdl import get_performance_frequency
from sdl import Event
from sdl import QuitEvent
from sdl import KeySym
from sdl import KeyDownEvent
from sdl import KeyCode
from sdl import Window
from sdl import Renderer
from sdl import Surface
from sdl import Texture
from sdl import Rect
from sdl import Color
from sdl import Font

TITLE: string = "Mystris"
BLOCK_SIZE: i64 = 20
TETRO_SIZE: i64 = 4
FIELD_HEIGHT: i64 = 20
FIELD_WIDTH: i64 = 10
WIN_WIDTH: i64 = BLOCK_SIZE * FIELD_WIDTH * 3
WIN_HEIGHT: i64 = BLOCK_SIZE * FIELD_HEIGHT
MYS_LOGO_PATH: string = "images/mys-logo-30-25.png"
FONT_PATH: string = "fonts/RobotoMono-Regular.ttf"
FONT_SIZE: i64 = 16

BACKGROUND_COLOR: Color = Color(0, 0, 0, 0)
FOREGROUND_COLOR: Color = Color(0, 170, 170, 0)
TETRO_COLORS: [Color] = [
    Color(0, 98, 192, 0),
    Color(202, 125, 95, 0),
    Color(0, 193, 191, 0),
    Color(0, 193, 0, 0),
    Color(191, 190, 0, 0),
    Color(209, 0, 191, 0),
    Color(209, 0, 0, 0)
]
TEXT_COLOR: Color = Color(202, 125, 95, 0)

@enum
class State:
    Running
    GameOver

class NesRandom:
    _previous_piece: i64

    def random(self) -> i64:
        piece = randint(0, 6)

        if piece == self._previous_piece:
            piece = randint(0, 6)

        self._previous_piece = piece

        return piece

class FrameTiming:
    ticks_per_frame: u64
    start_tick: u64

    def __init__(self):
        self.ticks_per_frame = get_performance_frequency() / 30

    def start(self):
        self.start_tick = get_performance_counter()

    def sleep_until_next_frame(self):
        frame_ticks = get_performance_counter() - self.start_tick

        if frame_ticks < self.ticks_per_frame:
            sleep_ticks = self.ticks_per_frame - frame_ticks
            sleep_time = f64(sleep_ticks) / f64(get_performance_frequency())
            sleep(sleep_time)

        self.start_tick = get_performance_counter()

class Block:
    x: i64
    y: i64

class Tetro:
    color_index: i64
    blocks: [Block]

class Game:
    width: i64
    height: i64
    screen: Surface
    texture: Texture
    mys_logo: Surface
    mys_logo_texture: Texture
    window: Window
    renderer: Renderer
    tetro_stats: [i64]
    tetro_total: i64
    key_fire: KeyCode
    state: State
    nes_random: NesRandom
    font: Font
    # field[y][x] contains the color of the block with (x,y) coordinates
    # "-1" border is to avoid bounds checking.
    # -1 -1 -1 -1
    # -1  0  0 -1
    # -1  0  0 -1
    # -1 -1 -1 -1
    field: [[i64]]
    # X offset of the game display
    x_offset: i64
    tetro: Tetro
    pos_y: i64
    pos_x: i64

    def __init__(self, width: i64, height: i64, title: string):
        self.width = width
        self.height = height
        self.tetro_total = 0
        self.tetro_stats = [0, 0, 0, 0, 0, 0, 0]
        self.window, self.renderer = create_window_and_renderer(width, height, 0)
        self.window.set_title(title)
        self.screen = create_rgb_surface(0,
                                         width,
                                         height,
                                         32,
                                         0x00ff0000,
                                         0x0000ff00,
                                         0x000000ff,
                                         0xff000000)
        self.texture = self.renderer.create_texture(width, height)
        self.mys_logo = img_load(MYS_LOGO_PATH)
        self.mys_logo_texture = self.renderer.create_texture_from_surface(self.mys_logo)
        self.key_fire = KeyCode.L
        self.state = State.Running
        self.nes_random = NesRandom()
        self.font = Font(FONT_PATH, FONT_SIZE)
        self.x_offset = 1
        self.tetro = Tetro(3, [Block(4, 4), Block(4, 5), Block(4, 6), Block(4, 7)])
        self.pos_y = 0
        self.pos_x = 0

        # Generate the field, fill it with 0's, add -1's on each edge
        self.field = []

        for i in range(FIELD_HEIGHT + 2):
            row: [i64] = []

            for j in range(FIELD_WIDTH + 2):
                row.append(0)

            row[0] = -1
            row[-1] = -1
            self.field.append(row)

        first_row = self.field[0]
        last_row = self.field[-1]

        for j in range(FIELD_WIDTH + 2):
            first_row[j] = -1
            last_row[j] = -1

    def run(self):
        frame_timing = FrameTiming()
        frame_timing.start()
        frame_counter = 0

        while True:
            frame_counter += 1

            # Just some dummy stats. Remove later.
            self.tetro_total += 1
            self.tetro_stats[self.nes_random.random()] += 1

            if frame_counter % 30 == 0:
                self.move_tetro_down()

            self.draw()

            if not self.handle_events():
                break

            frame_timing.sleep_until_next_frame()

    def draw(self):
        self.renderer.clear()
        self.draw_background()
        self.draw_tetro()
        self.draw_field()
        self.draw_vertial_splitters()
        self.draw_stats_bars()
        self.draw_middle()
        self.draw_logo()
        self.draw_stats_text()
        self.renderer.present()

    def draw_background(self):
        self.fill_rect(Rect(0, 0, self.width, self.height), BACKGROUND_COLOR)

    def draw_tetro(self):
        for block in self.tetro.blocks:
            self.draw_block(self.pos_y + block.y,
                            self.pos_x + block.x,
                            self.tetro.color_index)

    def draw_field(self):
        for i  in range(1, FIELD_HEIGHT + 1):
            for j in range(1, FIELD_WIDTH + 1):
                row = self.field[i]

                if row[j] > 0:
                    self.draw_block(i, j, row[j] - 1)

    def draw_block(self, x: i64, y: i64, color_index: i64):
        rect = Rect(self.x_offset + (y - 1) * BLOCK_SIZE, (x - 1) * BLOCK_SIZE,
                    BLOCK_SIZE - 1,
                    BLOCK_SIZE - 1)
        self.fill_rect(rect, TETRO_COLORS[color_index])

    def draw_vertial_splitters(self):
        rect = Rect(BLOCK_SIZE * FIELD_WIDTH + 2, 0, 2, self.height)
        self.fill_rect(rect, FOREGROUND_COLOR)
        rect.x = WIN_WIDTH - BLOCK_SIZE * FIELD_WIDTH - 4
        self.fill_rect(rect, FOREGROUND_COLOR)

    def draw_stats_bars(self):
        for i, stat in enumerate(self.tetro_stats):
            height = 10

            if self.tetro_total > 0:
                height += 90 * stat / self.tetro_total

            width = BLOCK_SIZE
            height = height * 4 * width / 100
            rect = Rect((WIN_WIDTH - 7 * (width + 1)) / 2 + i * (width + 1),
                        WIN_HEIGHT * 3 / 4 - height,
                        width,
                        height)
            self.fill_rect(rect, TETRO_COLORS[i])

    def draw_stats_text(self):
        self.draw_text(WIN_WIDTH / 3 + 10,
                       WIN_HEIGHT * 3 / 4,
                       f"stats: {self.tetro_total} tetros",
                       TEXT_COLOR)
        stats = ""

        for stat in self.tetro_stats:
            if self.tetro_total > 0:
                stat = 100 * stat / self.tetro_total

            stats += f" {stat}"

        self.draw_text(WIN_WIDTH / 3 - 8,
                       WIN_HEIGHT * 3 / 4 + 2 * FONT_SIZE,
                       stats,
                       TEXT_COLOR)

    def draw_middle(self):
        self.texture.update(self.screen)
        self.renderer.copy(self.texture, None)

    def draw_logo(self):
        tw, th = self.mys_logo_texture.query()
        self.renderer.copy(self.mys_logo_texture,
                           Rect((WIN_WIDTH - tw) / 2, 20, tw, th))

    def draw_text(self, x: i64, y: i64, text: string, color: Color):
        surface = self.font.render_solid(text, color)
        texture = self.renderer.create_texture_from_surface(surface)
        width, height = texture.query()
        self.renderer.copy(texture, Rect(x, y, width, height))

    def handle_events(self) -> bool:
        running = True

        while True:
            match poll_event():
                case QuitEvent():
                    running = False
                case KeyDownEvent() as event:
                    self.handle_key(event.keysym.sym)
                case _:
                    break

        return running

    def handle_key(self, key: KeyCode):
        if key == KeyCode.Space:
            self.handle_key_space()
        elif key == self.key_fire:
            self.handle_key_fire()

        if self.state != State.Running:
            return

        if key == KeyCode.Up:
            self.rotate_tetro()
        elif key == KeyCode.Left:
            self.move_tetro_left()
        elif key == KeyCode.Right:
            self.move_tetro_right()
        elif key == KeyCode.Down:
            self.move_tetro_down()

    def handle_key_space(self):
        print("handle_key_space")

    def handle_key_fire(self):
        print("handle_key_fire")

    def rotate_tetro(self):
        print("rotate_tetro")

    def move_tetro_left(self):
        self.move_tetro_side(-1)

    def move_tetro_right(self):
        self.move_tetro_side(1)

    def move_tetro_side(self, dx: i64) -> bool:
        # Reached left/right edge or another tetro?
        for block in self.tetro.blocks:
            y = block.y + self.pos_y
            x = block.x + self.pos_x + dx
            row = self.field[y]

            if row[x] != 0:
                # Do not move
                return False

        self.pos_x += dx

        return True

    def move_tetro_down(self):
        for block in self.tetro.blocks:
            y = block.y + self.pos_y + 1
            x = block.x + self.pos_x
            # Reached the bottom of the screen or another block?
            row = self.field[y]

            if row[x] != 0:
                # The new tetro has no space to drop => end of the game
                if self.pos_y < 2:
                    self.state = State.GameOver
                    self.tetro_total = 0
                    return

                # Drop it and generate a new one
                self.drop_tetro()
                # g.generate_tetro()
                # C.Mix_PlayChannel(0, g.sdl.actx.waves[0], 0)
                return

        self.pos_y += 1

    def drop_tetro(self):
        pass

    def fill_rect(self, rect: Rect, color: Color):
        value = self.screen.map_rgb(color.r, color.g, color.b)
        self.screen.fill_rect(rect, value)

def main():
    print("Mystris -- tribute to venerable Twintris")
    sdl_init()
    ttf_init()
    img_init()
    game = Game(WIN_WIDTH, WIN_HEIGHT, TITLE)
    game.run()
